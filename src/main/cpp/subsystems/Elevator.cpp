// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include <iostream>
#include "subsystems/Elevator.h"
#include <frc/smartdashboard/SmartDashboard.h>


// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

#include "RobotContainer.h"
#include "Globals.h"

Elevator::Elevator()
{
    SetName("Elevator");
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SetSubsystem("Elevator");

    m_elevatorMotorA = new rev::CANSparkMax(k_elevatorMotorA, rev::CANSparkMaxLowLevel::MotorType::kBrushless);
    m_elevatorMotorB = new rev::CANSparkMax(k_elevatorMotorB, rev::CANSparkMaxLowLevel::MotorType::kBrushless);
    m_endofactorMotor = new rev::CANSparkMax(k_endofactorMotor, rev::CANSparkMaxLowLevel::MotorType::kBrushless);

    m_elevatorPosition = 0.0;
    //m_elevatorFunction = Elevator::Elevator_Off;
    m_operatorJoystick = RobotContainer::GetInstance()->getOperator();
    m_elevatorEncoderA = new rev::SparkMaxRelativeEncoder(m_elevatorMotorA->GetEncoder());
    if(NULL != m_elevatorEncoderA) {
        m_elevatorEncoderA->SetPositionConversionFactor(1.0); // TBD: Need the conversion factor
    }

    m_elevatorEncoderB = new rev::SparkMaxRelativeEncoder(m_elevatorMotorB->GetEncoder());
    if(NULL != m_elevatorEncoderB) {
        m_elevatorEncoderB->SetPositionConversionFactor(1.0); // TBD: Need the conversion factor
    }



    // AddChild("EndoFactor Intake Out", &m_endoFactorIntakeOut);
    

    // AddChild("EndoFactor Deploy Out", &m_endoFactorDeployOut);
    

    // AddChild("Elevator Home Limit Switch", &m_elevatorAtHomeLimitSwitch);
    

    // AddChild("EndofactorMotor", &m_endofactorMotor);
    // m_endofactorMotor.SetInverted(false);

    // AddChild("ElevatorMotorB", &m_elevatorMotorB);
    // m_elevatorMotorB.SetInverted(false);

    // AddChild("ElevatorMotorA", &m_elevatorMotorA);
    // m_elevatorMotorA.SetInverted(false);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

}

bool Elevator::isElevatorAtHome() {

    if(m_elevatorAtHomeLimitSwitch.Get()) {
        return true;
    }

    return false;
}
double Elevator::getElevatorPosition() {

    double position = 0;
    double const k_maxDelta = 5.0; // TBD: Needs to determine
    double posA = m_elevatorEncoderA->GetPosition();
    double posB = m_elevatorEncoderB->GetPosition();

    if(k_maxDelta >= std::fabs(posA - posB)) {
        position = posA;
    }

    return position;
}

bool Elevator::setElevator(double speed) {
    if(k_maxElevatorSpeed > speed) {
        m_elevatorMotorA->Set(speed);
        m_elevatorMotorB->Set(speed);    
        
        // Print out for debugging
        std::cout << "Elevator Cmd: " << speed << std::endl;

        return true;
    }
    return false;
}

bool Elevator::setEndoFactor(double speed) {
    if(k_maxEndoFactorSpeed > speed) {
        m_endofactorMotor->Set(speed);
        
        // Print out for debugging
        std::cout << "EndoFactor Cmd: " << speed << std::endl;

        return true;
    }
    return false;
}

void Elevator::Periodic() {
    // Put code here to be run every loop
    RobotContainer *container = RobotContainer::GetInstance();
    if(NULL == container){
        return;
    }

    m_elevatorPosition = getElevatorPosition();
    double elevatorCommand = m_operatorJoystick->GetLeftX();
    bool elevatorOverride = m_operatorJoystick->GetRightBumper();

    if(k_jsDeadband < elevatorCommand) {
        setElevator(elevatorCommand);
    } else {
        setElevator(0);
    }

    // Endofactor operation
    double endofactorCmd = m_operatorJoystick->GetRightX();
    if(k_jsDeadband < endofactorCmd) {
        setEndoFactor(endofactorCmd);
    } else {
        setEndoFactor(0);
    }



    /////////  ELEVATOR FUNCTIONS  /////////////////////

    // Set the elevator function based on Joystick command
    // switch(m_elevatorFunction) {

    //     case Elevator_Off:
    //     default:
    //         break;
    //     case Elevator_ExtendManual:
    //         break;
    //     case Elevator_RetractManual:
    //         break;
    //     case Elevator_ExtendTarget1:
    //         break;
    //     case Elevator_ExtendTarget2:
    //         break;
    //     case Elevator_ExtendTarget3:
    //         break;
    // }




    // Print out for debugging
    // std::cout << "ElvCmd: " << elevatorCommand << ";  SpinCmd: " << endofactorCmd << ";" << std::endl;
}


void Elevator::SimulationPeriodic() {
    // This method will be called once per scheduler run when in simulation

}
