// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include <iostream>
#include "subsystems/Elevator.h"
#include <frc/smartdashboard/SmartDashboard.h>
#include "Globals.h"

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

#include "RobotContainer.h"

Elevator::Elevator()
{
    SetName("Elevator");
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SetSubsystem("Elevator");

    // m_elevatorMotorA = new rev::CANSparkMax(k_elevatorMotorA, rev::CANSparkMaxLowLevel::MotorType::kBrushless);
    // m_elevatorMotorB = new rev::CANSparkMax(k_elevatorMotorB, rev::CANSparkMaxLowLevel::MotorType::kBrushless);
    // m_endofactorMotor = new rev::CANSparkMax(k_endofactorMotor, rev::CANSparkMaxLowLevel::MotorType::kBrushless);
    // m_elevatorPID = new frc2::PIDController(k_P, k_I, k_D);

    // m_elevatorFunction = Elevator_Off;
    // m_operatorJoystick = RobotContainer::GetInstance()->getOperator();
    // m_elevatorEncoderA = new rev::SparkMaxRelativeEncoder(m_elevatorMotorA->GetEncoder());
    // if(NULL != m_elevatorEncoderA) {
    //     m_elevatorEncoderA->SetPositionConversionFactor(1.0); // TBD: Need the conversion factor
    // }

    // m_elevatorEncoderB = new rev::SparkMaxRelativeEncoder(m_elevatorMotorB->GetEncoder());
    // if(NULL != m_elevatorEncoderB) {
    //     m_elevatorEncoderB->SetPositionConversionFactor(1.0); // TBD: Need the conversion factor
    // }

    // m_elevatorPosition = 0.0;

    // // TODO: Hard coded elevator target. Need to determine.
    // m_elevatorTargetTop = 10.0;
    // m_elevatorTargetMiddle = 5.0;

    // m_elevatorMotorA = new rev::CANSparkMax(2, rev::CANSparkMaxLowLevel::MotorType::kBrushless);
    // m_elevatorEncoderA = new rev::SparkMaxRelativeEncoder(m_elevatorMotorA->GetEncoder());
}

bool Elevator::isElevatorAtHome() {

    // if(m_elevatorAtHomeLimitSwitch.Get()) {
    //     return true;
    // }

    return false;
}
double Elevator::getElevatorPosition() {

    // double position = 0;
    // double const k_maxDelta = 5.0; // TBD: Needs to determine. 
    // double posA = m_elevatorEncoderA->GetPosition();
    // double posB = m_elevatorEncoderB->GetPosition();

    // if(k_maxDelta >= std::fabs(posA - posB)) {
    //     position = posA;
    // }

    // return position;

    return 0;//m_elevatorEncoderA->GetPosition();
}

bool Elevator::setElevator(double speed) {
    // if(k_maxElevatorSpeed > std::fabs(speed)) {
    //     m_elevatorMotorA->Set(speed);
    //     m_elevatorMotorB->Set(speed);    

    //     return true;
    // }
    // return false;

    //m_elevatorMotorA->Set(speed);
    return true;
}

bool Elevator::setEndoFactor(double speed) {
    // if(k_maxEndoFactorSpeed > speed) {
    //     m_endofactorMotor->Set(speed);
    //     return true;
    // }
    return false;
}

void Elevator::Periodic() {
    // Put code here to be run every loop

}


void Elevator::SimulationPeriodic() {
    // This method will be called once per scheduler run when in simulation

}

void Elevator::runElevator() {

    /////////  Routine ELEVATOR FUNCTIONS  /////////////////////

    // double elevatorSpeedCmd = 0.0;
    // bool elevatorOverride = m_operatorJoystick->GetRightBumper();
    // m_elevatorPosition = getElevatorPosition();

    // if(elevatorOverride) {
    //     // Manual operation
    //     m_elevatorFunction = Elevator_Off;
    //     elevatorSpeedCmd = m_operatorJoystick->GetLeftX();
    //     if(k_jsDeadband < elevatorSpeedCmd) {
    //         setElevator(elevatorSpeedCmd);
    //     } else {
    //         setElevator(0);
    //     }
    // } else {
    //     // Need to set the motor speed to zero BEFORE checking for a button input
    //     // Get the target command
    //     if(m_operatorJoystick->GetAButtonPressed()) {
    //         m_elevatorFunction = Elevator_DeployTargetTop;
    //     } else if(m_operatorJoystick->GetBButtonPressed()) {
    //         m_elevatorFunction = Elevator_DeployTargetMiddle;
    //     } else if(m_operatorJoystick->GetStartButton()) {
    //         m_elevatorFunction = Elevator_Stow;
    //     }
    // }

    // // Set the elevator function based on Joystick command
    // switch(m_elevatorFunction) {

    //     case Elevator_Off:
    //     default:
    //         break;
    //     case Elevator_DeployTargetTop:
    //         if(k_delta >= std::fabs(m_elevatorPosition - m_elevatorTargetTop)) {
    //             elevatorSpeedCmd = m_elevatorPID->Calculate(m_elevatorPosition, m_elevatorTargetTop);
    //         } else {
    //             m_elevatorFunction = Elevator_Off;
    //         }
    //         break;
    //     case Elevator_DeployTargetMiddle:
    //         if(k_delta >= std::fabs(m_elevatorPosition - m_elevatorTargetMiddle)) {
    //             elevatorSpeedCmd = m_elevatorPID->Calculate(m_elevatorPosition, m_elevatorTargetMiddle);
    //         } else {
    //             m_elevatorFunction = Elevator_Off;
    //         }
    //         break;
    //     case Elevator_Stow:
    //         if(!isElevatorAtHome() &&
    //            m_operatorJoystick->GetLeftBumper() && m_operatorJoystick->GetRightBumper()) {
    //             elevatorSpeedCmd = 0.5;
    //         } else {
    //             m_elevatorFunction = Elevator_Off;
    //         }
    //         break;
    // }

    double elevatorSpeedCmd = m_operatorJoystick->GetLeftX();
    setElevator(elevatorSpeedCmd);

    //////////////// Endofactor operation ////////////////////
    
    // double endofactorCmd = m_operatorJoystick->GetRightX();
    // if(k_jsDeadband < endofactorCmd) {
    //     setEndoFactor(endofactorCmd);
    // } else {
    //     setEndoFactor(0);
    // }




    // Print out for debugging
    std::cout << "ElevPosition: " << m_elevatorPosition << ";  ElevCmd: " << elevatorSpeedCmd << ";" << std::endl;
    // std::cout << "EndoFactorCmd: " << endofactorCmd << std::endl;

}