// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

#include <iostream>
#include "subsystems/Elevator.h"
#include <frc/smartdashboard/SmartDashboard.h>
#include "Globals.h"

#include "RobotContainer.h"

Elevator::Elevator()
{
    SetName("Elevator");
    SetSubsystem("Elevator");

    m_elevatorMotorA = new rev::CANSparkMax(k_elevatorMotorA, rev::CANSparkMaxLowLevel::MotorType::kBrushless);
    m_elevatorMotorB = new rev::CANSparkMax(k_elevatorMotorB, rev::CANSparkMaxLowLevel::MotorType::kBrushless);
    m_endofactorMotor = new rev::CANSparkMax(k_endofactorMotor, rev::CANSparkMaxLowLevel::MotorType::kBrushless);
    m_elevatorPID = new frc2::PIDController(k_P, k_I, k_D);

    m_elevatorFunction = Elevator_Off;
    m_elevatorEncoderA = new rev::SparkMaxRelativeEncoder(m_elevatorMotorA->GetEncoder());
    if(NULL != m_elevatorEncoderA) {
        m_elevatorEncoderA->SetPositionConversionFactor(1.0); // TBD: Need the conversion factor
    }

    m_elevatorEncoderB = new rev::SparkMaxRelativeEncoder(m_elevatorMotorB->GetEncoder());
    if(NULL != m_elevatorEncoderB) {
        m_elevatorEncoderB->SetPositionConversionFactor(1.0); // TBD: Need the conversion factor
    }

    m_elevatorPosition = 0.0;
    m_scoringTarget = 0.0;
    m_isCone = false;
}

bool Elevator::isElevatorAtHome() {

    if(m_elevatorAtHomeLimitSwitch.Get()) {
        return true;
    }

    return false;
}
double Elevator::getElevatorPosition() {

    double position = 0;
    double const k_maxDelta = 5.0; // TBD: Needs to determine. 
    double posA = m_elevatorEncoderA->GetPosition();
    double posB = m_elevatorEncoderB->GetPosition();

    if(k_maxDelta >= std::fabs(posA - posB)) {
        position = posA;
    }

    return position;
}

bool Elevator::setElevator(double speed) {
    if(k_maxElevatorSpeed > std::fabs(speed)) {
        m_elevatorMotorA->Set(speed);
        m_elevatorMotorB->Set(speed);    

        return true;
    }
    return false;
}

bool Elevator::setEndoFactor(double speed) {
    if(k_maxEndoFactorSpeed > speed) {
        m_endofactorMotor->Set(speed);
        return true;
    }
    return false;
}

void Elevator::Periodic() {
    // Put code here to be run every loop

    m_operatorJoystick = RobotContainer::GetInstance()->getOperator();
}


void Elevator::SimulationPeriodic() {
    // This method will be called once per scheduler run when in simulation

}

void Elevator::runElevator() {

    /////////  Routine ELEVATOR FUNCTIONS  /////////////////////

    double elevatorSpeedCmd = 0.0;
    bool elevatorOverride = m_operatorJoystick->GetRightBumper();
    m_elevatorPosition = getElevatorPosition();

    if(elevatorOverride) {
        // Manual operation
        m_elevatorFunction = Elevator_Off;
        elevatorSpeedCmd = m_operatorJoystick->GetLeftX();
        if(k_jsDeadband > std::fabs(elevatorSpeedCmd)) {
            elevatorSpeedCmd = 0.0;
        }
    } else {
        // Need to set the motor speed to zero BEFORE checking for a button input
        // Get the target command
        if(m_operatorJoystick->GetAButton()) {
            if(m_isCone) {
                m_scoringTarget = k_elevatorTargetTopCone;
            } else {
                m_scoringTarget = k_elevatorTargetTopCube;
            }
            m_elevatorFunction = Elevator_DeployTargetTop;
        } else if(m_operatorJoystick->GetBButton()) {
            if(m_isCone) {
                m_scoringTarget = k_elevatorTargetMiddleCone;
            } else {
                m_scoringTarget = k_elevatorTargetMiddleCube;
            }
            m_elevatorFunction = Elevator_DeployTargetMiddle;
        } else if(m_operatorJoystick->GetXButton()) {
            m_scoringTarget = k_elevatorReceiveGamePiece;
            m_elevatorFunction = Elevator_RecieveGamePiece;
        } else if(!isElevatorAtHome() &&
            m_operatorJoystick->GetLeftBumper() && m_operatorJoystick->GetRightBumper()) {
            m_elevatorFunction = Elevator_Stow;
        } 
    }

    // Set the elevator function based+ on Joystick command
    switch(m_elevatorFunction) {

        case Elevator_Off:
        default:
            break;
        case Elevator_DeployTargetTop:
        case Elevator_DeployTargetMiddle:
        case Elevator_RecieveGamePiece:
            if(k_delta >= std::fabs(m_elevatorPosition - m_scoringTarget)) {
                elevatorSpeedCmd = m_elevatorPID->Calculate(m_elevatorPosition, m_scoringTarget);
            } else {
                m_elevatorFunction = Elevator_Off;
            }
            break;
        case Elevator_Stow:
            elevatorSpeedCmd = 0.5;
            break;
    }

    setElevator(elevatorSpeedCmd);

    //////////////// Endofactor operation ////////////////////
    
    double endofactorCmd = m_operatorJoystick->GetRightX();
    if(k_jsDeadband < endofactorCmd) {
        setEndoFactor(endofactorCmd);
    } else {
        setEndoFactor(0);
    }

    // Grabber operation
    // Keep it open until it senses a Cone
    m_endoFactorGrabberOut.Set(true);
    


    // Print out for debugging
    std::cout << "ElevPosition: " << m_elevatorPosition << ";  ElevCmd: " << elevatorSpeedCmd << ";" << std::endl;
    std::cout << "EndoFactorCmd: " << endofactorCmd << std::endl;

}

bool Elevator::stowElevator() {

}
