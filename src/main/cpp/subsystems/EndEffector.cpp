// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

#include <iostream>
#include "subsystems/EndEffector.h"
#include <frc/smartdashboard/SmartDashboard.h>

#include "RobotContainer.h"

EndEffector::EndEffector()
{
    SetName("EndEffector");
    SetSubsystem("EndEffector");

    m_endEffectorMotor = new rev::CANSparkMax(k_endofactorMotor, rev::CANSparkMaxLowLevel::MotorType::kBrushless);
    m_endEffectorMotor->SetInverted(true);

    // m_coneLED = new frc::DigitalOutput(5);
    // m_cubeLED = new frc::DigitalOutput(6);
}


// Put code here to be run every loop
void EndEffector::Periodic() 
{ 
    // Check cone or cube
    int checkConeOrCube = m_operatorJoystick->GetPOV();
    if ((checkConeOrCube >= 0 && checkConeOrCube <= 90) || (checkConeOrCube > 270))
    {
        m_isCone = true;
        // m_cubeLED->Set(false);
        // m_coneLED->Set(true);
    }
    else if (checkConeOrCube > 90 && checkConeOrCube < 270)
    {
        m_isCone = false;
        // m_coneLED->Set(false);
        // m_cubeLED->Set(true);
        
    }
}    

void EndEffector::Initialize() 
{
    m_isCone = true;
    m_operatorJoystick = RobotContainer::GetInstance()->getOperator();
}

// This method will be called once per scheduler run when in simulation
void EndEffector::SimulationPeriodic() {}

//////////////// endEffector operation ////////////////////

void EndEffector::setEndEffectorRoller(double speed) 
{
    m_endEffectorMotor->Set(speed);
}

void EndEffector::runEndEffector() 
{
    /////////////// End Effector Operation ///////////////////

    double endEffectorRollerIn = m_operatorJoystick->GetRightTriggerAxis();
    double endEffectorRollerOut = m_operatorJoystick->GetLeftTriggerAxis();
    double endEffectorRollerSpeed = 0;

    if(fabs(endEffectorRollerIn) > k_jsDeadband) 
    {
        if(m_isCone) 
        {
            setEndEffectorRoller(endEffectorRollerIn);
        } 
        else
        {
            setEndEffectorRoller(-endEffectorRollerIn);
        }
    } 
    else if(fabs(endEffectorRollerOut) > k_jsDeadband)
    {
        if(m_isCone)
        {
            setEndEffectorRoller(-endEffectorRollerOut);
        }
        else 
        {
            setEndEffectorRoller(endEffectorRollerOut);
        }
    }
    else
    {
        setEndEffectorRoller(0);
    }

    setEndEffectorRoller(endEffectorRollerSpeed * k_endEffectorSpeedFactor);
  
}